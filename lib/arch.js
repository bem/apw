var Q = require('qq'),
    INHERIT = require('inherit'),
    ASSERTS = require('./asserts'),
    Plan = require('./plan'),
    util = require('./util'),
    arraySlice = Array.prototype.slice,

    nodeIDSequence = 1;

module.exports = INHERIT({

    /**
     * Create an instance of Arch.
     *
     * @constructor
     */
    __constructor: function() {
        this.nodes = {};
        this.parents = {};
        this.children = {};
        this.plans = {};
        this.locked = 0;
    },

    /**
     * Apply function on this Arch.
     *
     * @param {Function} fn Function to apply.
     * @returns {Arch} Chainable API.
     */
    apply: function(fn) {
        fn.apply(this, arraySlice.call(arguments, 1));
        return this;
    },

    /**
     * Lock this arch and it's plans.
     *
     * @returns {Arch} Chainable API.
     */
    lock: function() {
        this.locked++;

        for (var k in this.plans) {
            this.plans[k].lock();
        }

        return this;
    },

    /**
     * Unlock this arch and its plans.
     *
     * @returns {Arch} Chainable API.
     */
    unlock: function() {
        if (this.locked) this.locked--;

        for (var k in this.plans) {
            this.plans[k].unlock();
        }

        return this;
    },

    /**
     * Call function inside lock()/unlock() pair.
     *
     * @param {Function} cb Function to call.
     * @param {Object} context Call context.
     * @returns {promise} The result of Q.when().fin().
     */
    withLock: function(cb, context) {
        var _this = this;
        this.lock();
        return Q.when(cb.apply(context))
            .fin(function() {
                _this.unlock();
            });
    },

    /**
     * Add new node.
     * If id argument is absent, autogenerated ID will be used.
     *
     * @param {String} [id] Node ID.
     * @param {Object} node Node to add.
     * @param {String[]|String} [parents] Parent node IDs to link with.
     * @param {String[]|String} [children] Child node IDs to link with.
     * @returns {String} Node ID.
     */
    setNode: function(id, node, parents, children) {
        if (id && typeof id !== 'string') {
            children = parents;
            parents = node;
            node = id;
            id = null;
        }
        if (!id) id = (node.getId && node.getId())? node.getId() : nodeIDSequence++;

        this.nodes[id] = node;

        // TODO: seems like copy-paste between parents and childs
        // Proposal: add private method for both link types management
        if (!this.parents[id] || (parents && parents !== true)) this.parents[id] = [];
        if (parents && parents !== true) {
            this.link([id], parents);
        }

        if (!this.children[id] || (children && children !== true)) this.children[id] = [];
        if (children && children !== true) {
            this.link(children, [id]);
        }

        return id;
    },

    /**
     * Replace node 'body'.
     *
     * @param {String} id ID of node to replace.
     * @param {Object} node New node.
     * @returns {String} Node ID.
     */
    replaceNode: function(id, node) {
        var args = arraySlice.call(arguments);
        args = (args.length < 2? [null] : []).concat(args, [true, true]);
        return this.setNode.apply(this, args);
    },

    /**
     * Check if node with such ID exists in this arch.
     *
     * @param {String} id Node ID to check.
     * @returns {boolean} True if exists, otherwise false.
     */
    hasNode: function(id) {
        return !!this.nodes[id];
    },

    /**
     * Check if node with such ID has parents with provided IDs.
     *
     * @param {String} id Child node ID to check.
     * @param {String|String[]} parents Parent IDs to check.
     * @returns {boolean} True if all IDs are parent for this child, otherwise false.
     */
    hasParents: function(id, parents) {
        ASSERTS.hasId(id, this);
        return util.hasLink(id, this, 'parents', parents);
    },

    /**
     * Check if node with such ID has children with provided IDs.
     *
     * @param {String} id Parent node ID to check.
     * @param {String|String[]} children Child IDs to check.
     * @returns {boolean} True if all IDs are children for this parent, otherwise false.
     */
    hasChildren: function(id, children) {
        ASSERTS.hasId(id, this);
        return util.hasLink(id, this, 'children', children);
    },

    /**
     * Return node by ID.
     * If there are no such node, return default node.
     *
     * @param {String} id Node id
     * @returns {Object} Node object
     */
    getNode: function(id) {
        return this.hasNode(id)? this.nodes[id] : this.getDefaultNode(id);
    },

    /**
     * Create and return stub node for ID.
     * NB: it is not belongs to this Arch, just utility function.
     *
     * @param {String} id ID of node to create.
     * @returns {Object} Object with .getId() and .run() inside.
     */
    getDefaultNode: function(id) {
        return {
            getId: function() {
                return id;
            },

            run: function() {
                return Q.reject("** No rule to make target '" + id + "'");
            }
        };
    },

    /**
     * Return node children IDs.
     *
     * @param {String} id Node ID.
     * @returns {String[]} Children IDs.
     */
    getChildren: function(id) {
        ASSERTS.hasId(id, this);
        return [].concat(this.children[id] || []);
    },

    /**
     * Return node parent IDs.
     *
     * @param {String} id Node ID.
     * @returns {String[]} Parent IDs.
     */
    getParents: function(id) {
        ASSERTS.hasId(id, this);
        return [].concat(this.parents[id] || []);
    },

    /**
     * Link nodes.
     *
     * @param {String[]|String} children IDs of child nodes.
     * @param {String[]|String} parents IDs of parent nodes.
     * @returns {Arch} Chainable API.
     */
    link: function(children, parents) {
//ASSERT: все children должны существовать — позволяет выявить попытки работать с несуществующими нодами.
//ASSERT: все parents должны существовать — позволяет выявить попытки работать с несуществующими нодами.
//ASSERT: не позволять loop.
        parents = util.toArray(parents);
        util.toArray(children).forEach(function(child) {
            this._link(child, parents);
        }, this);

        return this;
    },

    /**
     * Link child node with parents.
     *
     * @param {String} child Child node ID.
     * @param {Array} parents Parent nodes IDs.
     */
    _link: function(child, parents) {
        var _parents = this.parents[child],
            children;

        parents.forEach(function(parent) {
            if (this.hasParents(child, parent)) return;

            children = this.children[parent] || (this.children[parent] = []);

            if (_parents.indexOf(parent) === -1) _parents.push(parent);
            if (children.indexOf(child) === -1) children.push(child);

            for (var k in this.plans) {
                var p = this.plans[k];
                if (p.hasNode(child) || p.hasNode(parent)) p.link(child, parent);
            }
        }, this);
    },

    /**
     * Unlink linked (child-parent) nodes.
     *
     * @param {String} id1 First node ID to unlink.
     * @param {String} id2 Second node ID to unlink.
     * @returns {Arch} Chainable API.
     */
    unlink: function(id1, id2) {
        ASSERTS.hasId(id1, this);
        ASSERTS.hasId(id2, this);

        util.unlink(this.parents[id1], this.children[id1], id2);
        util.unlink(this.parents[id2], this.children[id2], id1);

        for (var k in this.plans) {
            var p = this.plans[k];
            if (p.hasNode(id1) && p.hasNode(id2)) p.unlink(id1, id2);
        }

        return this;
    },

    /**
     * Remove tree from arch.
     * Use forced removal to remove nodes with links to other parents (not belonging to removed tree).
     * So in "A->[B,C]->D" arch (D is the child of both B and C) forced removal will remove D node.
     *
     * @param {String} id Tree root node ID.
     * @param {boolean} forced Remove child nodes with links to other parents too.
     * @returns {Arch} Chainable API.
     */
    removeTree: function(id, forced) {
        ASSERTS.hasId(id, this);
        var children = this.children[id];

        children.forEach(function(cId) {
            this._removeTree(cId, forced);
        }, this);

        this.removeNode(id);

        return this;
    },

    _removeTree: function(id, forced) {
        if (this.parents[id].length === 1 || forced) {
            var children = this.children[id];

            children.forEach(function(cId) {
                this._removeTree(cId, forced);
            }, this);

            this.removeNode(id);
        }
    },

    /**
     * Remove node from arch.
     *
     * @param {String} id Node ID to remove.
     * @returns {Arch} Chainable API.
     */
    removeNode: function(id) {
        ASSERTS.hasId(id, this);
        util.removeNode(this.children, this.parents, id);

        delete this.nodes[id];

        for (var k in this.plans) {
            var p = this.plans[k];
            if (p.hasNode(id)) p.removeNode(id);
        }

        return this;
    },

    /**
     * Create plan instance from this arch.
     * Targets are (is) node IDs to run. If you have A -> B -> C arch and it is needed to build 'A', you target is 'A'.
     *
     * @param {Array|String} targets Node IDs to build.
     * @returns {Plan} Created plan.
     */
    createPlan: function(targets) {
//ASSERT: такие targets должны существовать — позволяет выявить попытки работать с несуществующими нодами.
        var _this = this,
            plan = new Plan(this, targets, '__plan_root__');

        // register plan
        this.plans[plan.getId()] = plan;

        // unregister plan
        plan.on('allDone', function() {
            delete _this.plans[plan.getId()];
        });

        return plan;
    },

    /**
     * Return IDs of root (without parents) nodes.
     *
     * @returns {String[]} IDs of root nodes.
     */
    findRoots: function() {
        return Object.keys(this.parents).filter(function(id) {
            return !this.parents[id].length;
        }, this);
    },

    /**
     * Dump this arch to string for debug purposes.
     *
     * @returns {String} String representation of this arch.
     */
    toString: function() {
        return 'Graph:\n' +
            this.findRoots().map(function(r) {
                    return '== root\n' + this.nodeToString(r, ' ')
                }, this).join('')
    },

    /**
     * Dump this arch to Graphviz string for debug purposes.
     *
     * @returns {String} Graphviz string representation of this arch.
     */
    toGraphviz: function() {
        return 'digraph G {\n' +
            this.findRoots().map(function(r) {
                    return this.nodeToGraphviz(r)
                }, this).join('') + '}\n';
    },

    /**
     * Dump node with its children to string.
     *
     * @param {String} id Node ID to dump.
     * @param {String} spaces Left indent spaces.
     */
    nodeToString: function(id, spaces) {
        spaces = spaces || ' ';

        return spaces + id + '\n' +
            this.children[id].map(function(c) {
                    return spaces + this.nodeToString(c, spaces + ' ')
                }, this).join('')
    },

    /**
     * Dump node with its children to Graphviz string.
     *
     * @param {String} id Node ID to dump.
     */
    nodeToGraphviz: function(id, done) {
        var thisNode = '"' + id + '"',
            s = '    ' + thisNode + ';\n',
            children = this.children[id] || [];

        if (!(id in done)) done[id] = {};

        children.forEach(function(child) {
            if (!done[id][child]) {
                s += '    ' + thisNode + ' -> "' + child + '";\n';
            }
        });
        children.forEach(function(child) {
            if (!done[id][child]) {
                done[id][child] = 1;
                s += this.nodeToGraphviz(child, done);
            }
        }, this);

        return s;
    }

});
